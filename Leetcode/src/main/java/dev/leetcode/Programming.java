package dev.leetcode;

import java.util.*;

/**
 * Leetcode problems of 'Proramming Skills' category.
 */
public class Programming {

    /**
     * 389. Find the Difference
     * <p>You are given two strings s and t.</p>
     *
     * <p>String t is generated by random shuffling string s and then add one more letter
     * at a random position.</p>
     * <p>Return the letter that was added to t.</p>
     *
     * Example 1:
     * <p>Input: s = "abcd", t = "abcde"
     * Output: "e"
     * Explanation: 'e' is the letter that was added.</p>
     *
     * Example 2:
     * <p>Input: s = "", t = "y"
     * Output: "y" </p>
     *
     * Constraints:
     * <ul>
     * <li>0 <= s.length <= 1000 </li>
     * <li>t.length == s.length + 1 </li>
     * <li>s and t consist of lowercase English letters.</li>
     * </ul>
     * @param s
     * @param t
     *
     * @return ch
     */
    public char findDifference(String s, String t) {
        /*
        if(s.isEmpty()) {
            return t.charAt(0);
        }
        List<Character> charArray = s.chars().mapToObj(ch -> (char) ch)
                .collect(Collectors.toList());
        return t.chars()
                .mapToObj(ch -> (char) ch)
                .filter(ch -> !charArray.contains(ch))
                .findFirst().get().charValue();

         */
        if (s == null || s.isEmpty())   return t.charAt(0);

        char ch = t.charAt(t.length()-1);
        for (int idx = 0; idx < s.length(); idx++)  {
            ch ^= (char) (s.charAt(idx) ^ t.charAt(idx));
        }

        return ch;
    }

    /**
     * 1768. Merge Strings Alternately
     * <p>You are given two strings word1 and word2. Merge the strings by adding letters in
     * alternating order, starting with word1. If a string is longer than the other, append
     * the additional letters onto the end of the merged string. </p>
     *
     * <p>Return the merged string.</p>
     *
     * Example 1:
     * <p>Input: word1 = "abc", word2 = "pqr"
     * Output: "apbqcr"
     * Explanation: The merged string will be merged as so:
     * word1:  a   b   c
     * word2:    p   q   r
     * merged: a p b q c r
     * </p>
     *
     * Example 2:
     * <p>Input: word1 = "ab", word2 = "pqrs"
     * Output: "apbqrs"
     * Explanation: Notice that as word2 is longer, "rs" is appended to the end.
     * word1:  a   b
     * word2:    p   q   r   s
     * merged: a p b q   r   s
     * </p>
     * Example 3:
     * <p>Input: word1 = "abcd", word2 = "pq"
     * Output: "apbqcd"
     * Explanation: Notice that as word1 is longer, "cd" is appended to the end.
     * word1:  a   b   c   d
     * word2:    p   q
     * merged: a p b q c   d
     * </p>
     * <p>Constraints: <code>
     * 1 <= word1.length, word2.length <= 100 <br>
     * word1 and word2 consist of lowercase English letters. </code> </p>
     *
     * @param word1
     * @param word2
     *
     * @return mergedString
     */
    public String mergeStrings(String word1, String word2) {
        int wordLen1 = word1.length();
        int wordLen2 = word2.length();

        int maxLength = Math.max(wordLen1, wordLen2);
        int itr=0;

        StringBuilder builder = new StringBuilder();
        while (itr < maxLength) {
            if (itr < wordLen1) builder.append(word1.charAt(itr));
            if (itr < wordLen2) builder.append(word2.charAt(itr));
            itr++;
        }

        return builder.toString();
    }

    /**
     * 242. Valid Anagram
     * <p>Given two strings s and t, return true if t is an anagram of s,
     * and false otherwise.</p>
     *
     * <p>An Anagram is a word or phrase formed by rearranging the letters of a different
     * word or phrase, typically using all the original letters exactly once.</p>
     *
     * Example 1:
     * <p>Input: s = "anagram", t = "nagaram"
     * Output: true </p>
     *
     * Example 2:
     * <p>Input: s = "rat", t = "car"
     * Output: false </p>
     *
     * Constraints:
     * <p><code>
     * 1 <= s.length, t.length <= 5 * 10^4</p>
     * <p>s and t consist of lowercase English letters.</p>
     * </code></p>
     *
     * <p>Follow up: What if the inputs contain Unicode characters? How would you adapt
     * your solution to such a case? </p>
     *
     * @param word1
     * @param word2
     *
     * return true/false
     */
    public boolean isAnagram(String word1, String word2) {
        if (word1.length() != word2.length()) return false;

        int[] charCount = new int[26];

        for (char ch : word1.toCharArray()) {
            charCount[ch - 'a']++;
        }

        for (char ch : word2.toCharArray()) {
            charCount[ch - 'a']--;
        }

        for (int val : charCount)   {
            if (val != 0)   return false;
        }

        return true;
    }

    /**
     * 28. Find the Index of the First Occurrence in a String
     * <p>Given two strings needle and haystack, return the index of the first occurrence
     * of needle in haystack, or -1 if needle is not part of haystack. </p>
     *
     * Example 1:
     * <p>Input: haystack = "sadbutsad", needle = "sad"
     * Output: 0
     * Explanation: "sad" occurs at index 0 and 6.
     * The first occurrence is at index 0, so we return 0. </p>
     *
     * Example 2:
     * <p>Input: haystack = "leetcode", needle = "leeto"
     * Output: -1
     * Explanation: "leeto" did not occur in "leetcode", so we return -1. </p>
     *
     * Constraints:
     * <code>
     * <p> 1 <= haystack.length, needle.length <= 104 </p>
     * <p> haystack and needle consist of only lowercase English characters. </p>
     * </code>
     *
     * @param haystack
     * @param needle
     *
     * @return
     */
    public int strStr(String haystack, String needle) {

        int hLen = haystack.length();
        int nLen = needle.length();

        if (hLen < nLen)    return -1;

        for (int i = 0, j=nLen; j <= hLen; i++, j++)    {
            if (haystack.substring(i, j).equals(needle)) {
                return i;
            }
        }

        return -1;
    }

    /**
     * 459. Repeated Substring Pattern
     * <p>Given a string s, check if it can be constructed by taking a substring of it
     * and appending multiple copies of the substring together. </p>
     *
     * Example 1:
     * <p>Input: s = "abab"
     * Output: true
     * Explanation: It is the substring "ab" twice. </p>
     *
     * Example 2:
     * <p>Input: s = "aba"
     * Output: false </p>
     *
     * Example 3:
     * <p>Input: s = "abcabcabcabc"
     * Output: true
     * Explanation: It is the substring "abc" four times or the substring "abcabc" twice. </p>
     *
     * Constraints:
     * <code>
     * <p> 1 <= s.length <= 10^4 </p>
     * <p> s consists of lowercase English letters. </p>
     * </code>
     *
     * @param s
     * @return
     *
     */
    public boolean repeatedSubstringPattern(String s) {
        /*
        String twice = s+s;
        twice = twice.substring(1, twice.length()-1);

        return twice.contains(s);
        */
        int n = s.length();
        for (int i = 1; i <= n / 2; i++) {
            if (n % i == 0) {
                String substring = s.substring(0, i);
                StringBuilder repeated = new StringBuilder();
                for (int j = 0; j < n / i; j++) {
                    repeated.append(substring);
                }
                if (repeated.toString().equals(s)) return true;
            }
        }
        return false;
    }


    /**
     * 283. Move Zeroes
     * <p>Given an integer array nums, move all 0's to the end of it while
     * maintaining the relative order of the non-zero elements. </p>
     *
     * <p>Note that you must do this in-place without making a copy of the array. </p>
     *
     * Example 1:
     * <p>Input: nums = [0,1,0,3,12]
     * Output: [1,3,12,0,0] </p>
     *
     * Example 2:
     * <p>Input: nums = [0]
     * Output: [0]  </p>
     *
     * Constraints:
     * <code>
     * <p>1 <= nums.length <= 10^4 </p>
     * <p>-2^31 <= nums[i] <= 2^31 - 1 </p>
     * </code>
     *
     * <p>Follow up: Could you minimize the total number of operations done? </p>
     *
     * @param nums
     * @return
     */
    public int[] moveZeroes(int[] nums) {
        if (nums == null || nums.length < 2)    return nums;

        int left = 0;
        for (int right = 0; right < nums.length; right++)   {
            if (nums[right] != 0)   {
                int temp = nums[right];
                nums[right] = nums[left];
                nums[left] = temp;
                left++;
            }
        }

        return nums;
    }

    /**
     * 66. Plus One
     * <p>You are given a large integer represented as an integer array digits, where each
     * digits[i] is the ith digit of the integer. The digits are ordered from most
     * significant to least significant in left-to-right order. The large integer does not
     * contain any leading 0's.</p>
     *
     * <p>Increment the large integer by one and return the resulting array of digits.</p>
     * <pre>
     * Example 1:
     * Input: digits = [1,2,3]
     * Output: [1,2,4]
     * Explanation: The array represents the integer 123.
     * Incrementing by one gives 123 + 1 = 124.
     * Thus, the result should be [1,2,4].
     *
     * Example 2:
     * Input: digits = [4,3,2,1]
     * Output: [4,3,2,2]
     * Explanation: The array represents the integer 4321.
     * Incrementing by one gives 4321 + 1 = 4322.
     * Thus, the result should be [4,3,2,2].
     *
     * Example 3:
     * Input: digits = [9]
     * Output: [1,0]
     * Explanation: The array represents the integer 9.
     * Incrementing by one gives 9 + 1 = 10.
     * Thus, the result should be [1,0].
     * </pre>
     * Constraints:
     * <ul>
     * <li>1 <= digits.length <= 100 </li>
     * <li>0 <= digits[i] <= 9 </li>
     * <li>digits does not contain any leading 0's. </li>
     * </ul>
     *
     * @param digits
     * @return
     */
    public int[] plusOne(int[] digits) {
        int len = digits.length;

        for (int i = len -1; i >= 0; i--)   {
            if (digits[i] < 9)  {
                digits[i]++;
                return digits;
            }
            digits[i] = 0;
        }

        digits = new int[digits.length+1];
        digits[0] = 1;

        return digits;
    }

    /**
     * 1822. Sign of the Product of an Array
     * <pre>
     * There is a function signFunc(x) that returns:
     * 1 if x is positive.
     * -1 if x is negative.
     * 0 if x is equal to 0.
     * You are given an integer array nums.
     * Let product be the product of all values in the array nums.
     *
     * Return signFunc(product).
     *
     * Example 1:
     * Input: nums = [-1,-2,-3,-4,3,2,1]
     * Output: 1
     * Explanation: The product of all values in the array is 144, and signFunc(144) = 1
     *
     * Example 2:
     * Input: nums = [1,5,0,2,-3]
     * Output: 0
     * Explanation: The product of all values in the array is 0, and signFunc(0) = 0
     *
     * Example 3:
     * Input: nums = [-1,1,-1,1,-1]
     * Output: -1
     * Explanation: The product of all values in the array is -1, and signFunc(-1) = -1
     *
     * Constraints:
     * 1 <= nums.length <= 1000
     * -100 <= nums[i] <= 100
     * </pre>
     *
     * @param nums
     * @return
     *      1 if x is positive.
     *      -1 if x is negative.
     *      0 if x is equal to 0.
     */
    public int arraySign(int[] nums) {
        /*
        if ((Arrays.stream(nums).reduce(0, (a, b) -> ((b == 0) ? (1) : (a) ) ) ) > 0)
            return 0;

        int negativeCount = Arrays.stream(nums).reduce(0, (a, b) -> ((b < 0) ? ++a : a));

        return (negativeCount % 2 == 1) ? -1 : 1;
         */
        int negatives = 0;

        for (int n : nums)  {
            if (n == 0) {
                return 0;
            } else if (n < 0) {
                negatives++;
            }
        }
        return (negatives % 2 == 0) ? 1 : -1;
    }

    /**
     * 1502. Can Make Arithmetic Progression From Sequence
     * <pre>
     * A sequence of numbers is called an arithmetic progression if the difference between
     * any two consecutive elements is the same.
     *
     * Given an array of numbers arr, return true if the array can be rearranged to form
     * an arithmetic progression. Otherwise, return false.
     *
     * Example 1:
     * Input: arr = [3,5,1]
     * Output: true
     * Explanation: We can reorder the elements as [1,3,5] or [5,3,1] with differences 2
     * and -2 respectively, between each consecutive elements.
     *
     * Example 2:
     * Input: arr = [1,2,4]
     * Output: false
     * Explanation: There is no way to reorder the elements to obtain an arithmetic progression.
     * </pre>
     *
     * Constraints:
     * <ul>
     * <li>2 <= arr.length <= 1000 </li>
     * <li>-10^6 <= arr[i] <= 10^6 </li>
     * </ul>
     *
     * @param array
     * @return
     *
     */
    public boolean canMakeArithmeticProgression(int[] array) {
        if (array == null || array.length < 2) return false;

        Arrays.sort(array);
        int diff = array[0] - array[1];

        for (int i = 1; i < (array.length - 1); i++)    {
            if ((array[i] - array[i+1]) != diff)    {
                return false;
            }
        }

        return true;
    }

    /**
     * 896. Monotonic Array
     * <pre>
     * An array is monotonic if it is either monotone increasing or monotone decreasing.
     *
     * An array nums is monotone increasing if for all i <= j, nums[i] <= nums[j].
     * An array nums is monotone decreasing if for all i <= j, nums[i] >= nums[j].
     *
     * Given an integer array nums, return true if the given array is monotonic, or false otherwise.
     *
     * Example 1:
     * Input: nums = [1,2,2,3]
     * Output: true
     *
     * Example 2:
     * Input: nums = [6,5,4,4]
     * Output: true
     *
     * Example 3:
     * Input: nums = [1,3,2]
     * Output: false
     * </pre>
     *
     * Constraints:
     * <ul>
     * <li>1 <= nums.length <= 10^5 </li>
     * <li>-10^5 <= nums[i] <= 10^5 </li>
     * </ul>
     *
     * @param nums
     * @return
     */
    public boolean isMonotonic(int[] nums) {

        if (nums == null || nums.length < 1)   return false;

        int len = nums.length;
        if (len == 1)   return true;

        boolean ascends = (nums[0] < nums[len-1]);

        if (ascends)    {
            for (int i = 0; i < (len -1); i++)   {
                if (nums[i] > nums[i+1])    {
                    return false;
                }
            }
        } else  {
            for (int i = 0; i < (len -1); i++)   {
                if (nums[i] < nums[i+1])    {
                    return false;
                }
            }
        }
        return true;
    }

    /**
     * 13. Roman to Integer
     * <pre>
     * Roman numerals are represented by seven different symbols: I, V, X, L, C, D and M.
     *
     * Symbol       Value
     * I             1
     * V             5
     * X             10
     * L             50
     * C             100
     * D             500
     * M             1000
     * For example, 2 is written as II in Roman numeral, just two ones added together.
     * 12 is written as XII, which is simply X + II. The number 27 is written as XXVII,
     * which is XX + V + II.
     *
     * Roman numerals are usually written largest to smallest from left to right. However,
     * the numeral for four is not IIII. Instead, the number four is written as IV. Because
     * the one is before the five we subtract it making four. The same principle applies to
     * the number nine, which is written as IX. There are six instances where subtraction is used:
     *
     * I can be placed before V (5) and X (10) to make 4 and 9.
     * X can be placed before L (50) and C (100) to make 40 and 90.
     * C can be placed before D (500) and M (1000) to make 400 and 900.
     * Given a roman numeral, convert it to an integer.
     *
     * Example 1:
     * Input: s = "III"
     * Output: 3
     * Explanation: III = 3.
     *
     * Example 2:
     * Input: s = "LVIII"
     * Output: 58
     * Explanation: L = 50, V= 5, III = 3.
     *
     * Example 3:
     * Input: s = "MCMXCIV"
     * Output: 1994
     * Explanation: M = 1000, CM = 900, XC = 90 and IV = 4.
     * </pre>
     *
     * Constraints:
     * <ul>
     * <li>1 <= s.length <= 15 </li>
     * <li>s contains only the characters ('I', 'V', 'X', 'L', 'C', 'D', 'M'). </li>
     * <li>It is guaranteed that s is a valid roman numeral in the range [1, 3999]. </li>
     * </ul>
     *
     * @param numeral
     * @return
     */
    public int romanToInt(String numeral) {
        /* Didn't work
        int number = 0;

        for (int i = 0; i < (numeral.length() - 1); i++) {

            int lsb = RomanNumerals.valueOf(Character.toString(numeral.charAt(i))).getId();
            int lsbp = RomanNumerals.valueOf(Character.toString(numeral.charAt(i+1))).getId();

            if (lsb <= lsbp) {
                number += lsb;
            } else  {
                number += (lsbp-lsb);
            }
        }
        return number;
         */
        Map<Character, Integer> romanValues = new HashMap<>();
        romanValues.put('I', 1);
        romanValues.put('V', 5);
        romanValues.put('X', 10);
        romanValues.put('L', 50);
        romanValues.put('C', 100);
        romanValues.put('D', 500);
        romanValues.put('M', 1000);

        int result = 0;
        int prevValue = 0;

        for (int i = numeral.length() - 1; i >= 0; i--) {
            int value = romanValues.get(numeral.charAt(i));
            if (value < prevValue) {
                result -= value;
            } else {
                result += value;
            }
            prevValue = value;
        }

        return result;
    }

    /**
     * 58. Length of Last Word
     * <pre>
     * Given a string s consisting of words and spaces, return the length of the
     * last word in the string.
     *
     * A word is a maximal
     * substring
     *  consisting of non-space characters only.
     *
     * Example 1:
     * Input: s = "Hello World"
     * Output: 5
     * Explanation: The last word is "World" with length 5.
     *
     * Example 2:
     * Input: s = "   fly me   to   the moon  "
     * Output: 4
     * Explanation: The last word is "moon" with length 4.
     *
     * Example 3:
     * Input: s = "luffy is still joyboy"
     * Output: 6
     * Explanation: The last word is "joyboy" with length 6.
     * </pre>
     *
     * Constraints:
     * <ul>
     * <li> 1 <= s.length <= 10^4 </li>
     * <li> s consists of only English letters and spaces ' '. </li>
     * <li> There will be at least one word in s. </li>
     * </ul>
     *
     * @param sentence
     * @return length of last word.
     */
    public int lengthOfLastWord(String sentence) {
        sentence = sentence.trim();
        int length = 0;

        for (int i = sentence.length()-1; i >= 0; i--)    {
            if (sentence.charAt(i) != ' ')  {
                length++;
            } else {
                break;
            }
        }
        return length;
    }

    /**
     * 709. To Lower Case
     * <pre>
     * Given a string s, return the string after replacing every uppercase letter
     * with the same lowercase letter.
     *
     * Example 1:
     * Input: s = "Hello"
     * Output: "hello"
     *
     * Example 2:
     * Input: s = "here"
     * Output: "here"
     *
     * Example 3:
     * Input: s = "LOVELY"
     * Output: "lovely"
     *
     * Constraints:
     * 1 <= s.length <= 100
     * s consists of printable ASCII characters.
     * </pre>
     *
     * @param sentence
     * @return re-formed String
     */
    public String toLowerCase(String sentence) {
        /*
        char[] newStr = new char[sentence.length()];
        for (int i = 0; i < sentence.length(); i++)    {
            if (Character.isUpperCase(sentence.charAt(i))) {
                newStr[i] = Character.toLowerCase(sentence.charAt(i));
            } else {
                newStr[i] = sentence.charAt(i);
            }
        }
        return new String(newStr);
         */
        return sentence.toLowerCase();
    }

    /**
     * 682. Baseball Game
     * <pre>
     * You are keeping the scores for a baseball game with strange rules. At the beginning
     * of the game, you start with an empty record.
     *
     * You are given a list of strings operations, where operations[i] is the ith operation
     * you must apply to the record and is one of the following:
     *
     * An integer x.
     * Record a new score of x.
     * '+'.
     * Record a new score that is the sum of the previous two scores.
     * 'D'.
     * Record a new score that is the double of the previous score.
     * 'C'.
     * Invalidate the previous score, removing it from the record.
     * Return the sum of all the scores on the record after applying all the operations.
     *
     * The test cases are generated such that the answer and all intermediate calculations
     * fit in a 32-bit integer and that all operations are valid.
     *
     * Example 1:
     * Input: ops = ["5","2","C","D","+"]
     * Output: 30
     * Explanation:
     * "5" - Add 5 to the record, record is now [5].
     * "2" - Add 2 to the record, record is now [5, 2].
     * "C" - Invalidate and remove the previous score, record is now [5].
     * "D" - Add 2 * 5 = 10 to the record, record is now [5, 10].
     * "+" - Add 5 + 10 = 15 to the record, record is now [5, 10, 15].
     * The total sum is 5 + 10 + 15 = 30.
     *
     * Example 2:
     * Input: ops = ["5","-2","4","C","D","9","+","+"]
     * Output: 27
     * Explanation:
     * "5" - Add 5 to the record, record is now [5].
     * "-2" - Add -2 to the record, record is now [5, -2].
     * "4" - Add 4 to the record, record is now [5, -2, 4].
     * "C" - Invalidate and remove the previous score, record is now [5, -2].
     * "D" - Add 2 * -2 = -4 to the record, record is now [5, -2, -4].
     * "9" - Add 9 to the record, record is now [5, -2, -4, 9].
     * "+" - Add -4 + 9 = 5 to the record, record is now [5, -2, -4, 9, 5].
     * "+" - Add 9 + 5 = 14 to the record, record is now [5, -2, -4, 9, 5, 14].
     * The total sum is 5 + -2 + -4 + 9 + 5 + 14 = 27.
     *
     * Example 3:
     * Input: ops = ["1","C"]
     * Output: 0
     * Explanation:
     * "1" - Add 1 to the record, record is now [1].
     * "C" - Invalidate and remove the previous score, record is now [].
     * Since the record is empty, the total sum is 0.
     *
     * Constraints:
     * 1 <= operations.length <= 1000
     * operations[i] is "C", "D", "+", or a string representing an integer in the range [-3 * 104, 3 * 104].
     * For operation "+", there will always be at least two previous scores on the record.
     * For operations "C" and "D", there will always be at least one previous score on the record.
     * </pre>
     *
     * @param operations
     * @return total
     */
    public int calPoints(String[] operations) {
        int total = 0;

        int[] record = new int[operations.length];
        int idx = 0;

        for (String op : operations)    {
            switch(op)  {
                case "C" -> record[--idx] = 0;
                case "D" -> {
                    record[idx] = record[idx-1] * 2;
                    idx++;
                }
                case "+" -> {
                    record[idx] = record[idx-1] + record[idx-2];
                    idx++;
                }
                default  -> {
                    record[idx] = Integer.parseInt(op);
                    idx++;
                }
            }
        }

        for (int n : record)    {
            total += n;
        }

        return total;
    }

    /**
     * 657. Robot Return to Origin
     * There is a robot starting at the position (0, 0), the origin, on a 2D plane. Given a
     * sequence of its moves, judge if this robot ends up at (0, 0) after it completes its moves.
     *
     * You are given a string moves that represents the move sequence of the robot where
     * moves[i] represents its ith move. Valid moves are 'R' (right), 'L' (left), 'U' (up),
     * and 'D' (down).
     *
     * Return true if the robot returns to the origin after it finishes all of its moves, or
     * false otherwise.
     *
     * Note: The way that the robot is "facing" is irrelevant. 'R' will always make the robot
     * move to the right once, 'L' will always make it move left, etc. Also, assume that the
     * magnitude of the robot's movement is the same for each move.
     *
     * Example 1:
     * Input: moves = "UD"
     * Output: true
     * Explanation: The robot moves up once, and then down once. All moves have the same
     * magnitude, so it ended up at the origin where it started. Therefore, we return true.
     *
     * Example 2:
     * Input: moves = "LL"
     * Output: false
     * Explanation: The robot moves left twice. It ends up two "moves" to the left of the
     * origin. We return false because it is not at the origin at the end of its moves.
     *
     *
     * Constraints:
     * 1 <= moves.length <= 2 * 104
     * moves only contains the characters 'U', 'D', 'L' and 'R'.
     *
     * @param moves
     * @return
     */
    public boolean judgeCircle(String moves) {
        int x = 0, y = 0;

        for(char ch : moves.toCharArray())      {
            switch(ch)  {
                case 'U' -> y++;
                case 'D' -> y--;
                case 'R' -> x++;
                case 'L' -> x--;
            }
        }

        return (x == 0 && y == 0);
    }

    /**
     * 1275. Find Winner on a Tic Tac Toe Game
     * <p>Tic-tac-toe is played by two players A and B on a 3 x 3 grid. </p>
     *
     * The rules of Tic-Tac-Toe are:
     * <p>Players take turns placing characters into empty squares ' '.
     * The first player A always places 'X' characters, while the second player B always
     * places 'O' characters. </p>
     * <p>'X' and 'O' characters are always placed into empty squares, never on filled ones.
     * The game ends when there are three of the same (non-empty) character filling any row,
     * column, or diagonal. </p>
     * <p>The game also ends if all squares are non-empty. </p>
     * <p>No more moves can be played if the game is over. </p>
     * <p>Given a 2D integer array moves where moves[i] = [rowi, coli] indicates that the ith move
     * will be played on grid[rowi][coli]. return the winner of the game if it exists (A or B).
     * In case the game ends in a draw return "Draw". If there are still movements to play
     * return "Pending". </p>
     *
     * <p>You can assume that moves is valid (i.e., it follows the rules of Tic-Tac-Toe), the grid
     * is initially empty, and A will play first. </p>
     *
     * Example 1:
     * <p>Input: moves = [[0,0],[2,0],[1,1],[2,1],[2,2]] </p>
     * Output: "A"
     * <p>Explanation: A wins, they always play first. </p>
     *
     * Example 2:
     * <p>Input: moves = [[0,0],[1,1],[0,1],[0,2],[1,0],[2,0]] </p>
     * Output: "B"
     * <p>Explanation: B wins. </p>
     *
     * Example 3:
     * <p>Input: moves = [[0,0],[1,1],[2,0],[1,0],[1,2],[2,1],[0,1],[0,2],[2,2]] </p>
     * Output: "Draw"
     * <p>Explanation: The game ends in a draw since there are no moves to make. </p>
     *
     * Constraints:
     * <p>1 <= moves.length <= 9 </p>
     * <p>moves[i].length == 2 </p>
     * <p>0 <= rowi, coli <= 2 </p>
     * <p>There are no repeated elements on moves. </p>
     * <p>moves follow the rules of tic tac toe. </p>
     *
     * <h3>Intuition</h3>
     * <p>To solve the problem, we must check the state of the Tic Tac Toe game after each
     * move and determine if any player has won, if the game is still ongoing, or if it's
     * a draw. My first thought is to track the count of marks for both players in rows,
     * columns, and diagonals. When a player makes a move, we can increment the corresponding
     * counters and check if any of them reach 3, which means a win. </p>
     *
     * <h3>Approach</h3>
     * <p>We create an array comb with 16 elements to count the player marks for rows, columns,
     * and diagonals separately for both players. Indexes 0-7 are used for player A and 8-15
     * for player B. As the players alternate turns, we use the turn index i to determine the
     * offset (0 or 8) for the player. We increment the counters for the rows, columns, and
     * diagonals based on the move. If any counter reaches 3, we have a winner and we return
     * "A" or "B" accordingly. If all moves are made and no winner is found, we return "Draw".
     * If there are remaining moves, the game is still "Pending". </p>
     *
     * <h3>Complexity</h3>
     * <p><b>Time complexity</b>: O(n)O(n)O(n) where n is the number of moves played. This is because
     * we iterate through each move once.</p>
     * <p><b>Space complexity</b>: O(1)O(1)O(1) as the space used does not grow with the number of
     * moves. We use a fixed-size array to keep track of the counters. </p>
     *
     * @param moves
     * @return
     */
    public String tictactoe(int[][] moves) {
        var comb = new short[16];
        for (int i = 0; i < moves.length; i++) {
            int offset = (8 * (i % 2));
            var move = moves[i];
            if (++comb[move[0] + offset] == 3                   ||
                ++comb[3 + move[1] + offset] == 3               ||
                (move[0] == move[1] && ++comb[6 + offset] == 3) ||
                (move[0] + move[1] == 2 && ++comb[7 + offset] == 3)) {
                return ((i % 2) == 0) ? "A" : "B";
            }
        }
        return moves.length == 9 ? "Draw" : "Pending";
    }

    /**
     * 1041. Robot Bounded In Circle
     * <p>On an infinite plane, a robot initially stands at (0, 0) and faces north. Note that:
     * <ul>
     * <li>The north direction is the positive direction of the y-axis. </li>
     * <li>The south direction is the negative direction of the y-axis. </li>
     * <li>The east direction is the positive direction of the x-axis. </li>
     * <li>The west direction is the negative direction of the x-axis. </li>
     * </ul> </p>
     * <pre>
     * The robot can receive one of three instructions:
     * "G": go straight 1 unit.
     * "L": turn 90 degrees to the left (i.e., anti-clockwise direction).
     * "R": turn 90 degrees to the right (i.e., clockwise direction).
     * The robot performs the instructions given in order, and repeats them forever.
     *
     * Return true if and only if there exists a circle in the plane such that the robot never
     * leaves the circle.
     *
     * Example 1:
     * Input: instructions = "GGLLGG"
     * Output: true
     * Explanation: The robot is initially at (0, 0) facing the north direction.
     * "G": move one step. Position: (0, 1). Direction: North.
     * "G": move one step. Position: (0, 2). Direction: North.
     * "L": turn 90 degrees anti-clockwise. Position: (0, 2). Direction: West.
     * "L": turn 90 degrees anti-clockwise. Position: (0, 2). Direction: South.
     * "G": move one step. Position: (0, 1). Direction: South.
     * "G": move one step. Position: (0, 0). Direction: South.
     * Repeating the instructions, the robot goes into the cycle: (0, 0) --> (0, 1) -->
     * (0, 2) --> (0, 1) --> (0, 0).
     * Based on that, we return true.
     *
     * Example 2:
     * Input: instructions = "GG"
     * Output: false
     * Explanation: The robot is initially at (0, 0) facing the north direction.
     * "G": move one step. Position: (0, 1). Direction: North.
     * "G": move one step. Position: (0, 2). Direction: North.
     * Repeating the instructions, keeps advancing in the north direction and does not go into cycles.
     * Based on that, we return false.
     *
     * Example 3:
     * Input: instructions = "GL"
     * Output: true
     * Explanation: The robot is initially at (0, 0) facing the north direction.
     * "G": move one step. Position: (0, 1). Direction: North.
     * "L": turn 90 degrees anti-clockwise. Position: (0, 1). Direction: West.
     * "G": move one step. Position: (-1, 1). Direction: West.
     * "L": turn 90 degrees anti-clockwise. Position: (-1, 1). Direction: South.
     * "G": move one step. Position: (-1, 0). Direction: South.
     * "L": turn 90 degrees anti-clockwise. Position: (-1, 0). Direction: East.
     * "G": move one step. Position: (0, 0). Direction: East.
     * "L": turn 90 degrees anti-clockwise. Position: (0, 0). Direction: North.
     * Repeating the instructions, the robot goes into the cycle: (0, 0) --> (0, 1) -->
     * (-1, 1) --> (-1, 0) --> (0, 0).
     * Based on that, we return true.
     * </pre>
     * Constraints:
     * <ul>
     * <li>1 <= instructions.length <= 100 </li>
     * </li>instructions[i] is 'G', 'L' or, 'R'. </li>
     * </ul>
     * <p> @see <a href="https://leetcode.com/problems/robot-bounded-in-circle/description/">
     *          Problem discussions</a> </p>
     *
     * @param instructions
     * @return
     */
    public boolean isRobotBounded(String instructions) {
        int[][] dir = {{0,1}, {-1, 0}, {0, -1}, {1,0}};
        int direction = 0;
        int x = 0;
        int y = 0;

        for(int s = 0; s < instructions.length(); s++){
            if(instructions.charAt(s) == 'L'){
                direction = (direction + 1) % 4;
            }
            else if(instructions.charAt(s) == 'R'){
                direction = (direction + 3) % 4;
            }
            else{
                x = x + dir[direction][0];
                y = y + dir[direction][1];
            }
        }
        return x == 0 && y == 0 || direction != 0;
    }

    /**
     * 1523. Count Odd Numbers in an Interval Range
     * <p>Given two non-negative integers low and high. Return the count of odd numbers
     * between low and high (inclusive). </p>
     *
     * Example 1:
     * <p>Input: low = 3, high = 7 </p>
     * Output: 3
     * <p>Explanation: The odd numbers between 3 and 7 are [3,5,7]. </p>
     *
     * Example 2:
     * <p>Input: low = 8, high = 10 </p>
     * Output: 1
     * <p>Explanation: The odd numbers between 8 and 10 are [9]. </p>
     *
     * Constraints:
     * <p>0 <= low <= high <= 10^9 </p>
     *
     * @param low
     * @param high
     *
     * @return count of odd numbers between low and high.
     */
    public int countOdds(int low, int high) {
        return (low%2 != 0 || high%2 != 0) ? ((high-low)/2)+1 : (high-low)/2;
    }

    /**
     * 1491. Average Salary Excluding the Minimum and Maximum Salary
     * You are given an array of unique integers salary where salary[i] is the salary of
     * the ith employee.
     *
     * Return the average salary of employees excluding the minimum and maximum salary.
     * Answers within 10-5 of the actual answer will be accepted.
     *
     * Example 1:
     * Input: salary = [4000,3000,1000,2000]
     * Output: 2500.00000
     * Explanation: Minimum salary and maximum salary are 1000 and 4000 respectively.
     * Average salary excluding minimum and maximum salary is (2000+3000) / 2 = 2500
     *
     * Example 2:
     * Input: salary = [1000,2000,3000]
     * Output: 2000.00000
     * Explanation: Minimum salary and maximum salary are 1000 and 3000 respectively.
     * Average salary excluding minimum and maximum salary is (2000) / 1 = 2000
     *
     * Constraints:
     * 3 <= salary.length <= 100
     * 1000 <= salary[i] <= 106
     * All the integers of salary are unique.
     */
    public double average(int[] salary) {
        int min = Integer.MAX_VALUE;
        int max = Integer.MIN_VALUE;
        double sum = 0;

        for (int val : salary)  {
            min = Math.min(min, val);
            max = Math.max(max, val);

            sum += val;
        }

        // calculate avg without min and max
        sum = (sum - (min + max))/(salary.length - 2);
        return sum;
    }

    /**
     * 860. Lemonade Change
     * <p>At a lemonade stand, each lemonade costs $5. Customers are standing in a queue to
     * buy from you and order one at a time (in the order specified by bills). Each customer
     * will only buy one lemonade and pay with either a $5, $10, or $20 bill. You must
     * provide the correct change to each customer so that the net transaction is that the
     * customer pays $5.</p>
     *
     * <p>Note that you do not have any change in hand at first.</p>
     *
     * <p>Given an integer array bills where bills[i] is the bill the ith customer pays, return
     * true if you can provide every customer with the correct change, or false otherwise.</p>
     *
     * <p>Example 1:
     * Input: bills = [5,5,5,10,20]
     * Output: true
     * Explanation:
     * From the first 3 customers, we collect three $5 bills in order.
     * From the fourth customer, we collect a $10 bill and give back a $5.
     * From the fifth customer, we give a $10 bill and a $5 bill.
     * Since all customers got correct change, we output true.</p>
     *
     * <p>Example 2:
     * Input: bills = [5,5,10,10,20]
     * Output: false
     * Explanation:
     * From the first two customers in order, we collect two $5 bills.
     * For the next two customers in order, we collect a $10 bill and give back a $5 bill.
     * For the last customer, we can not give the change of $15 back because we only have two $10 bills.
     * Since not every customer received the correct change, the answer is false.</p>
     *
     * <p>Constraints:
     * <code>
     * 1 <= bills.length <= 10^5
     * bills[i] is either 5, 10, or 20. </code></p>
     *
     */
    public boolean lemonadeChange(int[] bills) {
        int fives=0, tens=0;

        for (int received : bills)  {
            switch(received)    {
                case 5 -> fives++;
                case 10 ->  {
                    if (fives == 0) {
                        return false;
                    }
                    fives--;
                    tens++;
                }
                case 20 -> {
                    if (tens > 0 && fives > 0)  {
                        tens--;
                        fives--;
                    } else if (fives >= 3)  {
                        fives -= 3;
                    } else {
                        return false;
                    }
                }
                default -> {
                    return false;
                }
            }
        }

        return true;
    }

    /**
     * 1672. Richest Customer Wealth
     * <p>You are given an m x n integer grid accounts where accounts[i][j] is the
     * amount of money the ith customer has in the jth bank. Return the wealth that
     * the richest customer has. </p>
     *
     * <p>A customer's wealth is the amount of money they have in all their bank accounts.
     * The richest customer is the customer that has the maximum wealth. </p>
     *
     * Example 1:
     * Input: accounts = [[1,2,3],[3,2,1]]
     * Output: 6
     * Explanation:
     * 1st customer has wealth = 1 + 2 + 3 = 6
     * 2nd customer has wealth = 3 + 2 + 1 = 6
     * Both customers are considered the richest with a wealth of 6 each, so return 6.
     *
     * Example 2:
     * Input: accounts = [[1,5],[7,3],[3,5]]
     * Output: 10
     * Explanation:
     * 1st customer has wealth = 6
     * 2nd customer has wealth = 10
     * 3rd customer has wealth = 8
     * The 2nd customer is the richest with a wealth of 10.
     *
     * Example 3:
     * Input: accounts = [[2,8,7],[7,1,3],[1,9,5]]
     * Output: 17
     *
     * Constraints:
     * <ul>
     * <li>m == accounts.length </li>
     * <li>n == accounts[i].length </li>
     * <li>1 <= m, n <= 50 </li>
     * <li>1 <= accounts[i][j] <= 100 </li>
     * </ul>
     *
     * @param accounts
     * @return
     *
     */
    public int maximumWealth(int[][] accounts) {
        int maxWealth = Integer.MIN_VALUE;

        for (int[] account : accounts) {
            int sum = 0;
            for (int amt : account) {
                sum += amt;
            }
            maxWealth = Math.max(maxWealth, sum);
        }
        /*
        return Arrays.stream(accounts)
                     .mapToInt(account -> Arrays.stream(account).sum())
                     .max()
                     .orElse(Integer.MIN_VALUE);
        */
        return maxWealth;
    }

    /**
     * 1572. Matrix Diagonal Sum
     * @see <a href="https://leetcode.com/problems/matrix-diagonal-sum/description/">
     *     Explained with pictures</a>
     *
     * <p>Given a square matrix mat, return the sum of the matrix diagonals. </p>
     *
     * <p>Only include the sum of all the elements on the primary diagonal and all the
     * elements on the secondary diagonal that are not part of the primary diagonal. </p>
     *
     * Example 1:
     * Input: mat = [[1,2,3],
     *               [4,5,6],
     *               [7,8,9]]
     * Output: 25
     * Explanation: Diagonals sum: 1 + 5 + 9 + 3 + 7 = 25
     * Notice that element mat[1][1] = 5 is counted only once.
     *
     * Example 2:
     * Input: mat = [[1,1,1,1],
     *               [1,1,1,1],
     *               [1,1,1,1],
     *               [1,1,1,1]]
     * Output: 8
     *
     * Example 3:
     * Input: mat = [[5]]
     * Output: 5
     *
     * Constraints:
     * n == mat.length == mat[i].length
     * 1 <= n <= 100
     * 1 <= mat[i][j] <= 100
     *
     * @param matrix
     * @return
     */
    public int diagonalSum(int[][] matrix) {
        if (matrix == null || matrix.length < 1)    return -1;

        int cols = matrix.length;
        int rows = matrix[0].length;

        if (cols != rows)   return -1;

        int sum = 0;

        for (int idx = 0; idx < cols; idx++)    {
            sum += matrix[idx][idx]; //Primary diagonal
            sum += matrix[idx][cols - idx - 1];

            if (cols%2 == 1 && idx == cols/2)   {
                sum -= matrix[idx][idx];
            }
        }

        return sum;
    }

    /**
     * 54. Spiral Matrix
     *
     * @see <a href="https://leetcode.com/problems/spiral-matrix/description">
     *     explained with pictures</a>
     *
     * <p>Given an m x n matrix, return all elements of the matrix in spiral order. </p>
     *
     * Example 1:
     * Input: matrix = [[1,2,3],[4,5,6],[7,8,9]]
     * Output: [1,2,3,6,9,8,7,4,5]
     *
     * Example 2:
     * Input: matrix = [[1,2,3,4],[5,6,7,8],[9,10,11,12]]
     * Output: [1,2,3,4,8,12,11,10,9,5,6,7]
     *
     * Constraints:
     * m == matrix.length
     * n == matrix[i].length
     * 1 <= m, n <= 10
     * -100 <= matrix[i][j] <= 100
     *
     * @param matrix
     * @return
     */
    List<Integer> spiralOrder(int[][] matrix) {
        List<Integer> spiral = new ArrayList<>();
        if (matrix == null || matrix.length == 0) {
            return spiral;
        }

        int rows = matrix.length, cols = matrix[0].length;
        int left = 0, right = cols-1, top = 0, bottom = rows-1;

        while (left <= right && top <= bottom) {
            for (int i = left; i <= right; i++) {
                spiral.add(matrix[top][i]);
            }
            top++;

            for (int i = top; i <= bottom; i++) {
                spiral.add(matrix[i][right]);
            }
            right--;

            if (top <= bottom) {
                for (int i = right; i >= left; i--) {
                    spiral.add(matrix[bottom][i]);
                }
                bottom--;
            }

            if (left <= right) {
                for (int i = bottom; i >= top; i--) {
                    spiral.add(matrix[i][left]);
                }
                left++;
            }
        }
        return spiral;
    }

    record IndexPair (int row, int col) {}
    /**
     * 73. Set Matrix Zeroes
     * @see <a href="https://leetcode.com/problems/set-matrix-zeroes/description/">
     *     Explained with Pictures</a>
     *
     * Given an m x n integer matrix matrix, if an element is 0, set its entire row and
     * column to 0's.
     *
     * You must do it in place.
     *
     * Example 1:
     * Input: matrix = [[1,1,1],[1,0,1],[1,1,1]]
     * Output: [[1,0,1],[0,0,0],[1,0,1]]
     *
     * Example 2:
     * Input: matrix = [[0,1,2,0],[3,4,5,2],[1,3,1,5]]
     * Output: [[0,0,0,0],[0,4,5,0],[0,3,1,0]]
     *
     * Constraints:
     * m == matrix.length
     * n == matrix[0].length
     * 1 <= m, n <= 200
     * -2^31 <= matrix[i][j] <= 2^31 - 1
     *
     * Follow up:
     * A straightforward solution using O(mn) space is probably a bad idea.
     * A simple improvement uses O(m + n) space, but still not the best solution.
     * Could you devise a constant space solution?
     *
     * @param matrix
     */
    public int[][] setZeroes(int[][] matrix) {
        /*
        List<IndexPair> list = new ArrayList<>();
        for (int row = 0; row < matrix.length; row++) {
            for (int col = 0; col < matrix[row].length; col++)  {
                if (matrix[row][col] == 0)  {
                    list.add(new IndexPair(row, col));
                }
            }
        }

        for (IndexPair pair : list) {
            int row = pair.row(), col = pair.col();
            Arrays.fill(matrix[row], 0);
            for (int r = 0; r < matrix.length; r++) {
                matrix[r][col] = 0;
            }
        }
        return matrix;
         */
        int n = matrix.length;
        int m = matrix[0].length;

        int col0 = 1;

        // step 1: Traverse the matrix and mark 1st row & col accordingly:
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                if (matrix[i][j] == 0) {
                    // mark i-th row:
                    matrix[i][0] = 0;

                    // mark j-th column:
                    if (j != 0)
                        matrix[0][j] = 0;
                    else
                        col0 = 0;
                }
            }
        }

        // Step 2: Mark with 0 from (1,1) to (n-1, m-1):
        for (int i = 1; i < n; i++) {
            for (int j = 1; j < m; j++) {
                if (matrix[i][0] == 0 || matrix[0][j] == 0) {
                    matrix[i][j] = 0;
                }
            }
        }

        //step 3: Finally mark the 1st col & then 1st row:
        if (matrix[0][0] == 0) {
            for (int j = 0; j < m; j++) {
                matrix[0][j] = 0;
            }
        }
        if (col0 == 0) {
            for (int i = 0; i < n; i++) {
                matrix[i][0] = 0;
            }
        }
        return matrix;
    }

    /**
     * 976. Largest Perimeter Triangle
     * <pre>
     * Given an integer array nums, return the largest perimeter of a triangle with a
     * non-zero area, formed from three of these lengths. If it is impossible to form
     * any triangle of a non-zero area, return 0.
     *
     * Example 1:
     * Input: nums = [2,1,2]
     * Output: 5
     * Explanation: You can form a triangle with three side lengths: 1, 2, and 2.
     *
     * Example 2:
     * Input: nums = [1,2,1,10]
     * Output: 0
     * Explanation:
     * You cannot use the side lengths 1, 1, and 2 to form a triangle.
     * You cannot use the side lengths 1, 1, and 10 to form a triangle.
     * You cannot use the side lengths 1, 2, and 10 to form a triangle.
     * As we cannot use any three side lengths to form a triangle of non-zero area, we return 0.
     *
     * Constraints:
     * 3 <= nums.length <= 104
     * 1 <= nums[i] <= 106
     * </pre>
     *
     * @param nums
     * @return
     */
    public int largestPerimeter(int[] nums) {
        Arrays.sort(nums);
        for(int i=nums.length-1;i>1;i--)    {
            if(nums[i] < (nums[i-1]+nums[i-2])) {
                return nums[i]+nums[i-1]+nums[i-2];
            }
        }

        return 0;
    }

    /**
     * 1232. Check If It Is a Straight Line
     *
     * You are given an array coordinates, coordinates[i] = [x, y], where [x, y] represents
     * the coordinate of a point. Check if these points make a straight line in the XY plane.
     *
     * Example 1:
     * Input: coordinates = [[1,2],[2,3],[3,4],[4,5],[5,6],[6,7]]
     * Output: true
     *
     * Example 2:
     * Input: coordinates = [[1,1],[2,2],[3,4],[4,5],[5,6],[7,7]]
     * Output: false
     *
     * Constraints:
     * 2 <= coordinates.length <= 1000
     * coordinates[i].length == 2
     * -10^4 <= coordinates[i][0], coordinates[i][1] <= 10^4
     * coordinates contains no duplicate point.
     *
     * @see <a href="https://leetcode.com/problems/check-if-it-is-a-straight-line/solutions/620096/
 *                      java-python3-cpp-simple-code-with-explanation-100-fast-o-1-space">
     *      with explanation to solution </a>
     *
     * @param coordinates
     * @return
     */
    public boolean checkStraightLine(int[][] coordinates) {
        for(int i=2;i<coordinates.length;i++){
            if(!onLine(coordinates[i], coordinates[0], coordinates[1]))
                return false;
        }
        return true;
    }

    private boolean onLine(int[] p1, int[] p2, int[] p3){
        int x = p1[0], y = p1[1], x1 = p2[0], y1 = p2[1], x2 = p3[0], y2 = p3[1];
        return ((y - y1) * (x2 - x1) == (y2 - y1) * (x - x1));
    }

    /**
     * 67. Add Binary
     *
     * <p>
     *     Already solved. Refer {@link dev.leetcode.StringProblems}
     * </p>
     *
     * @param num1
     * @param num2
     *
     * @return
     */
    public String addBinary(String num1, String num2) {
        StringBuilder builder = new StringBuilder();
        int carryOver = 0;
        int maxLength = Math.max(num1.length(), num2.length());
        // To keep both the strings' length same
        num1 = "0".repeat(maxLength - num1.length()).concat(num1);
        num2 = "0".repeat(maxLength - num2.length()).concat(num2);

        for (int i = maxLength - 1; i >= 0; i--)    {

            int sum = carryOver;

            sum += num1.charAt(i) - '0';
            sum += num2.charAt(i) - '0';

            builder.append(sum % 2);
            carryOver = sum / 2;
        }
        if (carryOver > 0)  builder.append(carryOver);

        return builder.reverse().toString();
    }

    /**
     * 43. Multiply Strings
     *
     * <p>Given two non-negative integers num1 and num2 represented as strings, return the
     * product of num1 and num2, also represented as a string. </p>
     *
     * <p>Note: You must not use any built-in BigInteger library or convert the inputs to
     * integer directly.</p>
     *
     * Example 1:
     * Input: num1 = "2", num2 = "3"
     * Output: "6"
     *
     * Example 2:
     * Input: num1 = "123", num2 = "456"
     * Output: "56088"
     *
     * Constraints:
     * 1 <= num1.length, num2.length <= 200
     * num1 and num2 consist of digits only.
     * Both num1 and num2 do not contain any leading zero, except the number 0 itself.
     *
     * @param num1
     * @param num2
     * @return
     */
    public String multiply(String num1, String num2) {
        int n1Len = num1.length(), n2Len = num2.length();
        int[] pos = new int[n1Len + n2Len];

        for(int c1 = n1Len - 1; c1 >= 0; c1--) {
            for(int c2 = n2Len - 1; c2 >= 0; c2--) {
                int mul = (num1.charAt(c1) - '0') * (num2.charAt(c2) - '0');
                int p1 = c1 + c2;
                int p2 = c1 + c2 + 1;
                int sum = mul + pos[p2];

                pos[p1] += sum / 10;
                pos[p2] = (sum) % 10;
            }
        }

        StringBuilder sb = new StringBuilder();
        for(int p : pos)    {
            if(!(sb.isEmpty() && p == 0)) sb.append(p);
        }
        return sb.isEmpty() ? "0" : sb.toString();
    }

    /**
     * 50. Pow(x, n)
     * Implement pow(x, n), which calculates x raised to the power n (i.e., xn).
     *
     * Example 1:
     * Input: x = 2.00000, n = 10
     * Output: 1024.00000
     *
     * Example 2:
     * Input: x = 2.10000, n = 3
     * Output: 9.26100
     *
     * Example 3:
     * Input: x = 2.00000, n = -2
     * Output: 0.25000
     * Explanation: 2-2 = 1/22 = 1/4 = 0.25
     *
     * Constraints:
     * -100.0 < x < 100.0
     * -2^31 <= n <= 2^31-1
     * n is an integer.
     * Either x is not zero or n > 0.
     * -10^4 <= xn <= 10^4
     *
     * @see <a href="https://leetcode.com/problems/powx-n/solutions/1337794/java-c-simple-o-log-n-easy-faster-than-100-explained">
     *     Explained in detail.</a>
     *
     * @param x
     * @param n
     * @return
     */
    public double myPow(double x, int n) {

        if (n < 0) {
            n = -n;
            x = 1 / x;
        }

        double pow = 1;

        while (n != 0) {
            if ((n & 1) != 0) {
                pow *= x;
            }
            x *= x;
            n >>>= 1;
        }

        return pow;
    }

    class ListNode {
        int val;
        ListNode next;

        ListNode() {
        }

        ListNode(int val) {
            this.val = val;
        }

        ListNode(int val, ListNode next) {
            this.val = val;
            this.next = next;
        }
    }

    /**
     * 21. Merge Two Sorted Lists
     *
     * You are given the heads of two sorted linked lists list1 and list2.
     *
     * Merge the two lists into one sorted list. The list should be made by splicing
     * together the nodes of the first two lists.
     *
     * Return the head of the merged linked list.
     *
     * Example 1:
     * Input: list1 = [1,2,4], list2 = [1,3,4]
     * Output: [1,1,2,3,4,4]
     *
     * Example 2:
     * Input: list1 = [], list2 = []
     * Output: []
     *
     * Example 3:
     * Input: list1 = [], list2 = [0]
     * Output: [0]
     * <p>
     * @see <a href="https://leetcode.com/problems/merge-two-sorted-lists/description">
     *     Explained with diagrams</a> </p>
     *
     * <p>
     * @see <a href="https://leetcode.com/problems/merge-two-sorted-lists/solutions/3177193/simple-java-runtime-1-ms-beats-100">
     *     Solution explained in detail</a>
     * </p>
     *
     * Constraints:
     * The number of nodes in both lists is in the range [0, 50].
     * -100 <= Node.val <= 100
     * Both list1 and list2 are sorted in non-decreasing order.
     *
     * @param list1
     * @param list2
     *
     * @return
     */
    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
        if (list1 != null && list2 != null) {
            if (list1.val < list2.val) {
                list1.next = mergeTwoLists(list1.next, list2);
                return list1;
            } else {
                list2.next = mergeTwoLists(list1, list2.next);
                return list2;
            }
        }
        if (list1 == null)
            return list2;
        return list1;
    }

    /**
     * 206. Reverse Linked List
     * Given the head of a singly linked list, reverse the list, and return the reversed list.
     *
     * Example 1:
     * Input: head = [1,2,3,4,5]
     * Output: [5,4,3,2,1]
     *
     * Example 2:
     * Input: head = [1,2]
     * Output: [2,1]
     *
     * Example 3:
     * Input: head = []
     * Output: []
     *
     * @see <a href="https://leetcode.com/problems/reverse-linked-list/description/">
     *     Explained with diagrams</a>
     *
     * Constraints:
     * The number of nodes in the list is the range [0, 5000].
     * -5000 <= Node.val <= 5000
     *
     * Follow up: A linked list can be reversed either iteratively or recursively.
     * Could you implement both?
     *
     * @param head
     * @return
     */
    public ListNode reverseList(ListNode head) {

        ListNode reversed = null;
        ListNode current = head;

        while(current != null)    {
            ListNode next = current.next;
            current.next = reversed;
            reversed = current;

            current = next;
        }

        return reversed;
    }

    /**
     * 2. Add Two Numbers
     * You are given two non-empty linked lists representing two non-negative integers.
     * The digits are stored in reverse order, and each of their nodes contains a single
     * digit. Add the two numbers and return the sum as a linked list.
     *
     * You may assume the two numbers do not contain any leading zero, except the number 0 itself.
     * <p>
     * @see <a href="https://leetcode.com/problems/add-two-numbers/description/">
     *     Explained with diagrams </a>
     * </p>
     *
     * Example 1:
     * Input: l1 = [2,4,3], l2 = [5,6,4]
     * Output: [7,0,8]
     * Explanation: 342 + 465 = 807.
     *
     * Example 2:
     * Input: l1 = [0], l2 = [0]
     * Output: [0]
     *
     * Example 3:
     * Input: l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]
     * Output: [8,9,9,9,0,0,0,1]
     *
     * Constraints:
     * The number of nodes in each linked list is in the range [1, 100].
     * 0 <= Node.val <= 9
     * It is guaranteed that the list represents a number that does not have leading zeros.
     *
     * <p>
     * @see <a href="https://leetcode.com/problems/add-two-numbers/solutions/1835535/java-c-a-very-beautiful-explanation-ever-exists">
     *     Solution explained in detail</a>
     * </p>
     *
     * @param l1
     * @param l2
     * @return
     */
    public ListNode addTwoNumbers(ListNode l1, ListNode l2) {

        ListNode newList = new ListNode(0);
        ListNode current = newList;
        int carry = 0;

        while(l1 != null || l2 != null || carry == 1){
            int sum = 0;
            if(l1 != null){
                sum += l1.val;
                l1 = l1.next;
            }
            if(l2 != null){
                sum += l2.val;
                l2 = l2.next;
            }

            sum += carry;
            carry = sum/10;
            ListNode node = new ListNode(sum % 10);
            current.next = node;
            current = current.next;
        }

        return newList.next;
    }

    /**
     * 445. Add Two Numbers II
     * <p>You are given two non-empty linked lists representing two non-negative integers. The
     * most significant digit comes first and each of their nodes contains a single digit.
     * Add the two numbers and return the sum as a linked list. </p>
     *
     * <p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p>
     * <p>
     * @see <a href="https://leetcode.com/problems/add-two-numbers-ii/description">
     *     Problem with diagrams</a>
     * </p>
     *
     * Example 1:
     * Input: l1 = [7,2,4,3], l2 = [5,6,4]
     * Output: [7,8,0,7]
     *
     * Example 2:
     * Input: l1 = [2,4,3], l2 = [5,6,4]
     * Output: [8,0,7]
     *
     * Example 3:
     * Input: l1 = [0], l2 = [0]
     * Output: [0]
     *
     * Constraints:
     * The number of nodes in each linked list is in the range [1, 100].
     * 0 <= Node.val <= 9
     * It is guaranteed that the list represents a number that does not have leading zeros.
     *
     * @param l1
     * @param l2
     * @return
     */
    public ListNode addTwoNumbers2(ListNode l1, ListNode l2) {
        ListNode reversed1 = reverseList(l1);
        ListNode reversed2 = reverseList(l2);

        ListNode sum = addTwoNumbers(reversed1, reversed2);

        return reverseList(sum);
    }


}
